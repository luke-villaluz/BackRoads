from typing import List, Tuple
import networkx as nx
import osmnx as ox

# NOT kth shortest paths algo, this is literally returning more than 1 (k) routes
def k_shortest_routes(
    graph: nx.MultiDiGraph,
    origin: Tuple[float, float],
    destination: Tuple[float, float],
    weight: str = "scenic_cost",
    k: int = 5,
) -> List[List[int]]:
    """
    return up to k simple paths (lists of node ids) from originâ†’destination
    ordered by total 'weight'
    """
    # nearest_nodes expects (x=lon, y=lat)
    o = ox.nearest_nodes(graph, origin[1], origin[0])
    d = ox.nearest_nodes(graph, destination[1], destination[0])

    gen = nx.shortest_simple_paths(graph, o, d, weight=weight)

    routes: List[List[int]] = []
    for i, path in enumerate(gen):
        if i >= k:
            break
        routes.append(path)
    return routes


def path_time(graph: nx.MultiDiGraph, path: List[int]) -> float:
    """sum edge['travel_time'] along a node path (total time for route)"""
    total = 0.0
    for u, v in zip(path[:-1], path[1:]):
        # IMPORTANT this uses the first edge when looking at possibly multiple edges going from a to b
        data = graph[u][v][0]
        total += float(data.get("travel_time", 0.0))
    return total


def path_scenic_avg(graph: nx.MultiDiGraph, path: List[int]) -> float:
    """avg edge['scenic_score'] along a node path"""
    vals: List[float] = []
    for u, v in zip(path[:-1], path[1:]):
        data = graph[u][v][0]
        vals.append(float(data.get("scenic_score", 0.5)))
    return (sum(vals) / len(vals)) if vals else 0.0

# takes routes generated by k paths function at top
def rank_routes(
    graph: nx.MultiDiGraph,
    routes: List[List[int]],
    time_budget_factor: float = 1.30,
) -> List[Tuple[List[int], float, float]]:
    """
    Keep routes with time <= fastest_time * time_budget_factor,
    then sort by scenic average (descending).

    Returns:
        List of tuples: (path, scenic_avg, time_seconds)
    """
    if not routes:
        return []

    times = [path_time(graph, r) for r in routes]
    fastest_time = min(times)

    kept: List[Tuple[List[int], float, float]] = []
    for r, t in zip(routes, times):
        if t <= fastest_time * time_budget_factor:
            kept.append((r, path_scenic_avg(graph, r), t))

    kept.sort(key=lambda x: x[1], reverse=True)  # scenic desc
    return kept