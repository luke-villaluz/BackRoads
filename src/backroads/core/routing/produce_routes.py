# #!/usr/bin/env python3
from typing import List, Tuple
import networkx as nx
import osmnx as ox

from backroads.core.data.graph import load_graph
from backroads.core.routing.weighting import add_travel_time, add_scenic_weights, add_composite_cost
from backroads.core.routing.pathfinding import find_route, _nearest_node, _node_distance_heuristic
from backroads.core.utils.streets import print_route_street_names

'''
Produce Routes: 
    - Finds k-shortest routes
    - Ranks k routes
    - Returns top routes with directions and street names of the top route 
'''

def compute_route(graph, origin, destination, extra_minutes,
                  scenic_by_type, natural_by_type, profile="default"):

    # 1) Fastest route (by travel_time) using A*
    fastest_result = find_route(origin, destination, graph, weight="travel_time")
    fastest_nodes = fastest_result["nodes"]

    # compute fastest route travel time (seconds)
    fastest_time = 0.0
    for u, v in zip(fastest_nodes, fastest_nodes[1:]):
        data = graph.get_edge_data(u, v, default={})
        if isinstance(data, dict) and 0 in data:
            data = data[0]
        fastest_time += float(data.get("travel_time", 0.0))

    # If no extra time is allowed, just return this fastest route
    if extra_minutes <= 0:
        chosen_nodes = fastest_nodes
        chosen_cost = fastest_time           # keep this as travel_time in seconds
        chosen_weight = "travel_time"
    else:
        # 2) Scenic route (by scenic_score) using A*
        scenic_result = find_route(origin, destination, graph, weight="scenic_cost")
        scenic_nodes = scenic_result["nodes"]

        # compute scenic route travel time (also in seconds)
        scenic_time = 0.0
        for u, v in zip(scenic_nodes, scenic_nodes[1:]):
            data = graph.get_edge_data(u, v, default={})
            if isinstance(data, dict) and 0 in data:
                data = data[0]
            scenic_time += float(data.get("travel_time", 0.0))

        # Allowed time = fastest_time + extra slack
        allowed_time = fastest_time + extra_minutes * 60.0

        # If scenic route fits in the time budget, use it; otherwise fallback
        if scenic_time <= allowed_time:
            chosen_nodes = scenic_nodes
            chosen_cost = scenic_time        # cost = travel_time of scenic route
            chosen_weight = "scenic_cost"    # route chosen by scenic weight
        else:
            chosen_nodes = fastest_nodes
            chosen_cost = fastest_time
            chosen_weight = "travel_time"

    coords = [
        [graph.nodes[n]["x"], graph.nodes[n]["y"]]
        for n in chosen_nodes
    ]

    geojson = {
        "type": "Feature",
        "geometry": {
            "type": "LineString",
            "coordinates": coords
        },
        "properties": {
            "cost": chosen_cost,   # travel_time seconds
            "weight": chosen_weight,
        }
    }

    return {
        "geojson": geojson,
        "weights_used": {
            "scenic_by_type": scenic_by_type,
            "natural_by_type": natural_by_type,
        },
        "nodes": chosen_nodes,
    }

# NOT kth shortest paths algo, this is literally returning more than 1 (k) routes
from typing import List, Tuple
import networkx as nx
import osmnx as ox

# def k_candidate_routes(
#     graph: nx.MultiDiGraph,
#     origin: Tuple[float, float],
#     destination: Tuple[float, float],
#     weight: str = "scenic_cost",
#     k: int = 10,
# ) -> List[List[int]]:
#     """
#     Return up to k simple paths (lists of node ids) from originâ†’destination,
#     ordered by total `weight`.

#     Uses NetworkX's shortest_simple_paths (Dijkstra-based).
#     Scenic weights are fully respected.
#     """
#     # nearest_nodes expects (x=lon, y=lat)
#     o = ox.nearest_nodes(graph, origin[1], origin[0])
#     d = ox.nearest_nodes(graph, destination[1], destination[0])

#     # Convert MultiDiGraph -> DiGraph for this weight
#     simple = _to_simple_digraph(graph, weight=weight)

#     gen = nx.shortest_simple_paths(simple, o, d, weight=weight)

#     routes: List[List[int]] = []
#     for i, path in enumerate(gen):
#         if i >= k:
#             break
#         routes.append(path)
#     return routes


# def path_time(graph: nx.MultiDiGraph, path: List[int]) -> float:
#     """sum edge['travel_time'] along a node path (total time for route)"""
#     total = 0.0
#     for u, v in zip(path[:-1], path[1:]):
#         total += _edge_attr(graph, u, v, "travel_time", 0.0)
#     return total

# def path_scenic_avg(graph: nx.MultiDiGraph, path: List[int]) -> float:
#     """avg edge['scenic_score'] along a node path"""
#     vals: List[float] = []
#     for u, v in zip(path[:-1], path[1:]):
#         vals.append(_edge_attr(graph, u, v, "scenic_score", 0.5))
#     return (sum(vals) / len(vals)) if vals else 0.0

# # takes routes generated by k paths function at top
# # IMPORTANT: look at time_budget_factor
# def rank_routes(
#     graph: nx.MultiDiGraph,
#     routes: List[List[int]],
#     max_time_seconds: float,
# ) -> List[Tuple[List[int], float, float]]:
#     """
#     Keep routes with total time <= max_time_seconds,
#     then sort those by scenic average in descending order.

#     Returns:
#         List of tuples: (path, scenic_avg, time_seconds)
#     """
#     if not routes:
#         return []

#     kept: List[Tuple[List[int], float, float]] = []
#     for r in routes:
#         t = path_time(graph, r)
#         if t <= max_time_seconds:
#             kept.append((r, path_scenic_avg(graph, r), t))

#     kept.sort(key=lambda x: x[1], reverse=True)  # scenic desc
#     return kept

