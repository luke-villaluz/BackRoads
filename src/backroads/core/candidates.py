from typing import List, Tuple
import networkx as nx
import osmnx as ox

def _to_simple_digraph(G: nx.MultiDiGraph, weight: str) -> nx.DiGraph:
    """
    Collapse parallel edges to a single DiGraph edge per (u,v),
    keeping the edge with the MINIMUM value of `weight`.
    """
    H = nx.DiGraph()
    H.add_nodes_from(G.nodes(data=True))
    for u, v, key, data in G.edges(keys=True, data=True):
        w = float(data.get(weight, float("inf")))
        if H.has_edge(u, v):
            if w < float(H[u][v].get(weight, float("inf"))):
                H[u][v].clear()
                H[u][v].update(data)
        else:
            H.add_edge(u, v, **data)
    return H

def _edge_attr(G, u, v, attr: str, default: float) -> float:
    """
    Get an edge attribute for either a DiGraph (single edge) or
    a MultiDiGraph (parallel edges). For MultiDiGraph, we take the
    first edge’s attr; tweak if you prefer a different tie-breaker.
    """
    ed = G.get_edge_data(u, v)
    if ed is None:
        return default

    # DiGraph: ed is a flat attr dict
    if isinstance(ed, dict) and attr in ed:
        return float(ed.get(attr, default))

    # MultiDiGraph: ed is {key: {attrs}}
    if isinstance(ed, dict):
        first = next(iter(ed.values()))
        return float(first.get(attr, default))

    return default

# NOT kth shortest paths algo, this is literally returning more than 1 (k) routes
def k_shortest_routes(
    graph: nx.MultiDiGraph,
    origin: Tuple[float, float],
    destination: Tuple[float, float],
    weight: str = "scenic_cost",
    k: int = 10,  # number of routes generated
) -> List[List[int]]:
    """
    return up to k simple paths (lists of node ids) from origin→destination
    ordered by total 'weight'
    """
    # nearest_nodes expects (x=lon, y=lat)
    o = ox.nearest_nodes(graph, origin[1], origin[0])
    d = ox.nearest_nodes(graph, destination[1], destination[0])

    # Convert MultiDiGraph -> DiGraph for this weight
    simple = _to_simple_digraph(graph, weight=weight)

    gen = nx.shortest_simple_paths(simple, o, d, weight=weight)

    routes: List[List[int]] = []
    for i, path in enumerate(gen):
        if i >= k:
            break
        routes.append(path)
    return routes

def path_time(graph: nx.MultiDiGraph, path: List[int]) -> float:
    """sum edge['travel_time'] along a node path (total time for route)"""
    total = 0.0
    for u, v in zip(path[:-1], path[1:]):
        total += _edge_attr(graph, u, v, "travel_time", 0.0)
    return total

def path_scenic_avg(graph: nx.MultiDiGraph, path: List[int]) -> float:
    """avg edge['scenic_score'] along a node path"""
    vals: List[float] = []
    for u, v in zip(path[:-1], path[1:]):
        vals.append(_edge_attr(graph, u, v, "scenic_score", 0.5))
    return (sum(vals) / len(vals)) if vals else 0.0

# takes routes generated by k paths function at top
# IMPORTANT: look at time_budget_factor
def rank_routes(
    graph: nx.MultiDiGraph,
    routes: List[List[int]],
    time_budget_factor: float = 2.00,  # 1.30 means willing to allow times slower by up to 30%
) -> List[Tuple[List[int], float, float]]:
    """
    keeps routes with total time less than or equal to fastest_time times budget factor
    sort those routes by scenic average in descending order

    Returns:
        List of tuples: (path, scenic_avg, time_seconds)
    """
    if not routes:
        return []

    times = [path_time(graph, r) for r in routes]
    fastest_time = min(times)

    kept: List[Tuple[List[int], float, float]] = []
    for r, t in zip(routes, times):
        if t <= fastest_time * time_budget_factor:
            kept.append((r, path_scenic_avg(graph, r), t))

    kept.sort(key=lambda x: x[1], reverse=True)  # scenic desc
    return kept
